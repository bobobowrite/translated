# 基于Web攻击的异常检测

Gustavo Miguel Barroso Assis do Nascimento

MESTRADO EM SEGURANÇA INFORMÁTICA

November 2010

## 摘要

要成功阻止攻击, 建立一个全面和精准的检测系统是至关重要的.
基于特征的入侵检测系统(IDS)是其中最为流行的一种方法,
但是对于基于Web的攻击或者新型攻击的检测, 这些方法还不够令人满意.
本项目的目标是研究和设计一种能够检测这类攻击的异常入侵检测系统.

基于异常的 IDS 可以从一组训练数据中创建一个正常行为模型，然后用它来检
测新的攻击. 在大多数情况下，该模型表示的实例多于训练数据集中的实例，这
就是我们所指的泛化特征，也是准确异常检测所必需的. 此类系
统的准确性在很大程度上受到模型构建阶段(通常称为训练)的影响，模型构建
阶段取决于拥有不受攻击的数据，类似于受保护应用程序的正常操作. 拥有良好
的模型尤为重要，否则 IDS 可能会在检测阶段产生大量误报和漏报.

本论文详细介绍了我们关于使用基于异常的方法来检测对 Web 服务器和应用程
序的攻击的研究. 我们的贡献集中在三个不同的方面: i）高级训练程序, 即使
在复杂和动态的 Web 应用程序的情况下, 也能使基于异常的学习系统表现良好;
ii) 一个包含多种异常检测技术的系统，能够发现和鉴别针对 Web 服务器
和应用程序的攻击, 以及 iii) 使用来自部署于托管在葡萄牙 ISP 的生产服务器中的大
型 Web 应用程序的大量真实流量, 对系统和最适合的 Web 攻击异常检测的技术的使用进行了评估.

关键词: 异常检测 入侵检测 web攻击 计算机 网络

## 1 介绍

自从计算机存在以来，计算机网络就一直不停地增长和发展.
众所周知, 计算机网络已经成为银行、保险、军事等各个领域的大多数企业和组织发展的必备工具.
几个系统和网络之间的互连使得它们和大量的不断增长的多元化用户群体联通.
这些已知和未知的用户, 在访问这些网络时并不总是怀着善意. 
他们可以尝试读取、修改或破坏关键信息，或者只是攻击和扰乱系统. 
由于这些网络可能成为攻击的潜在目标, 因此确保它们的安全是一个不容忽视的重要方面.
在过去的二十年中, 互联网上发生的计算机安全事件数量的增加反映了互联网本身的发展。

作为 Internet 增长的一个方面, 超文本传输协议(HTTP)这些年来已被广泛使用.
如今, 应用程序被设计作为 Web 服务运行, 使用 HTTP 作为其标准通信协议部署在 Internet 上.
Web 应用程序的成功和广泛接受所形成的一种趋势, 表明人们将在未来几年严重依赖 Web 应用程序.
此类 Web 应用程序的流行引起了试图利用其漏洞的攻击者的注意.
根据2005年 CSI/FBI 计算机犯罪和安全调查[1], 95%的受访组织报告说他们经历过10多起与其网站相关的安全事件.

此外, 正如 CVE 漏洞趋势[2]在五年内显示的那样, 公开报告的 Web 应用程序漏洞总数急剧上升, 
甚至超过了缓冲区溢出漏洞. 促成这一趋势的三种最典型的网络相关攻击是: 
SQL 注入, 跨站点脚本 (XSS) 和远程文件包含 (RFI).
这种趋势的主要原因可以解释为易于发现和利用 Web 漏洞, 以及由缺乏经验的开
发人员编写的低级软件应用程序的激增.
![figure1.1](./papers/figures/1.1.jpg)
图 1.1 显示了多年来攻击复杂程度与入侵者所需技术知识的演变，是这种趋势的有力证据。

入侵检测(ID)是指计算机系统通过分析安全相关事件自动判断安全破坏事件的能力.
入侵检测系统(IDS)长期以来一直是理论研究和开发的课题,
并随着企业向互联网转移许多关键业务而获得主流关注.
这样的技术可以帮助提醒安全管理员实时发生在他们的系统和网络上的可疑活动.
入侵检测系统(IDS)通过检测入侵者, 可以在他们企图攻击或者入侵之前提供有关信息.

由于许多计算机系统基础设施容易受到攻击,
ID 成为了一个重要的技术业务部门.
作为一个活跃的研究领域[3], 可以帮助企业保持他们的系统, 进而他们的业务安全.
IDS 背后的主要思想是检测被监控资源的使用情况与正常行为的偏差.
考虑到当有人试图篡改系统时, 他/她将改变一些活动或者改变系统本身的参数, 
此类活动的结果应该偏离正常行为并因此被 IDS 检测到.

一个 IDS 可以根据几个特征进行分类, 例如,
其引擎分析的数据(主机/网络数据)种类及其检测异常的方式(签名或基于异常).
在这篇论文中, 我们特别关注的是检测针对 Web 服务器和应用程序的攻击时基于异常的 IDS, 
因为这些代表了当下涉及计算机网络相关安全问题的很大一部分.

为了检测已知的网络攻击，基于特征的 IDS 持有大量相关特征.
不幸的是, 它很难跟上网络漏洞的披露速度. 
因此, 基于特征的系统是不够的，应该加以补充基于异常检测的系统, 
这就是我们这项工作的主题.

### 1.1 动机和目标

基于异常的入侵检测系统有可能检测到新型的, 以前未知的攻击(也称为零day攻击).
然而, 这些系统通常会遭受高误报率, 并且可以通过模仿攻击(即试图作为正常行为通过的攻击的变体)来规避, 
例如通过使用字节替换和/或填充技术.
解决这些问题并提高基于异常的 IDS 的准确性的主要挑战之一在于控制模型的泛化.
基于异常的 IDS 从一组训练数据中学习并构建出正常行为模型.
正常行为是假定服务是根据其管理员的意图使用的, 换句话说, 它假设不存在攻击.

创建模型后, 后续观察到的偏离模型的情况被归类为异常.
为了实现不仅仅是简单地记住训练数据, 
基于异常的 IDS 必须泛化.
通过泛华, 基于异常的 IDS 接受与训练数据集相似但不一定相同的输入, 
这意味着被视为正常的实例集将是比训练数据中的实例集更大的集合.

泛化不足的异常检测系统会产生过多的误报, 而泛化过度的异常检测系统会漏报攻击.
因此, 正确的泛化是基于异常的 IDS 提高准确性的必要条件.

我们在研究中明确解决的另一个主要挑战是模型创建阶段(通常称为训练)对系统整体检测准确性的重大影响.
此阶段取决于用于模拟受保护系统或应用程序正常活动的流量或数据的质量,
这些流量或数据里应该免除利用了尚未公开的软件漏洞的零day攻击.

在本论文中, 我们提出了一种算法来清洗(即消除攻击)从网络流量中收集的 Web 请求数据集, 
以使其适合训练异常检测系统. 
此过程的主要目标是使基于异常的系统能够使用不包含攻击的输入数据构建其统计模型.

我们研究的另一个目标是设计一个基于异常的入侵检测系统, 该系统包含多种异常检测技术, 
可以基于区分正常请求和异常请求的模型来识别针对Web 服务器和应用程序的攻击.

作为我们研究的最终和主要目标, 我们使用生产环境大规模部署的一个web应用程序的真实流量
评估了基于异常的 IDS 的使用情况以及它包括的每一种异常检测技术的准确性.

### 1.2 论文概述

在第2章中, 我们通过讨论入侵检测将我们的工作置于研究背景中, 提供入侵检测系统
的分类及其作用和要求. 
然后我们讨论万维网 (WWW) 和超文本传输协议 (HTTP) 协议以及针对它的典型攻击类别.
接下来, 我们将讨论与使用 HTTP 协议攻击的异常检测相关的潜在问题.
总而言之, 我们介绍之前在基于Web 的攻击的异常检测领域的工作.

第3章详细介绍了我们对基于异常的 IDS 的使用研究, 其中用以研究的数据来自
于生成环境大规模部署的一个Web应用程序. 
我们讨论泛化的概念及其在异常检测中的重要性, 并解释应如何创建模型.

接下来, 我们提出了一种算法, 可用于清洗请求数据集,
以消除其中包含的攻击，以便它可用于训练异常检测系统.

此外, 我们解释了如何使用相似性度量来检测异常, 然后描述了先前文献中建议的九种不同算法来检
测网络流量中的异常, 讨论它们的优点和局限性.
进一步, 我们展示了我们基于异常的 IDS, 设计包含了所有这些算法以及我们使用的泛化启发式算法.

第4章介绍了我们的实验结果和对 Web 攻击异常检测算法的评估.
我们解释了我们如何获得和定义我们的数据集, 并简要说明我们的 IDS 是如何工作的.

然后我们根据每个模型所需的空间, 创建模型(训练)的运行时间以及使用它来测试异常(检测)来描述需求.
最后, 我们通过讨论每个模型的结果以及说明和比较它们之间的检测精度来分析每个模型.

在第5章中, 我们总结并指出了我们研究过程中遇到的一些问题, 强调了我们的贡献并讨论了未来的工作.

### 1.3 术语

在本文中, 首字母缩略词 IDS(入侵检测系统)以单数和复数形式使用, 以识别
基于网络(NIDS)和基于主机(HIDS)的入侵检测系统. 当指的是针对使用
HTTP 协议的万维网服务器或应用程序的请求或攻击时, 术语 web 和 http 可以互换使用.

## 2 上下文和相关工作

在本章中, 我们讨论入侵检测, 介绍定义, 评估方法, 并提出入侵检测系统的分类来概述其作用和必要条件.
然后我们讨论万维网和 HTTP 协议, Web漏洞以及针对 Web 服务器和应用程序的典型攻击类别.
接下来, 我们讨论与使用 HTTP 协议攻击的异常检测相关的潜在问题.
总而言之，我们陈述之前的在基于web的攻击的异常检测领域工作.

### 2.1 入侵检测

在讨论入侵检测之前, 我们必须定义什么是入侵.
入侵是相对于安全策略定义的,
它定义了对于一个系统什么是允许的什么是拒绝的.
除非你知道你的系统允许什么或不允许什么, 
否则尝试检测入侵意义不大.

**入侵**的定义是一组尝试危及某种资源的完整性, 机密性, 或可用性的行为[4].

**入侵检测**的定义是识别和响应针对计算和网络资源恶意行为的过程[5].

**入侵检测系统**则是监控计算机系统和/或网络活动以识别
恶意或可疑事件(即入侵). 
每当发生这样的事件时, IDS 会发出警报.

#### 2.1.1 评估

为了评估 IDS，我们首先需要选择好的度量指标来
能够确定其质量和检测能力.
然后我们需要在一些之前收集好的数据上运行它, 比如 DARPA
1999 IDS 数据集 [6], 
这是用以评估 IDS 的最流行的公开可用数据集.
IDS 的模型可以通过使用不同数据源的数据创建,
例如捕获网络数据包, 或者应用程序日志文件中的数据项,
这些都可以看作是IDS 的对象.

IDS 将判断每一个数据对象是否是攻击.
在基于特征的 IDS 中, 判断是根据 IDS 规则集数据库中存在的特征做出的，
而基于异常的 IDS 判断是依赖统计模型做出的.
无论哪种情况, IDS 都会将每个数据对象标记为正常或者攻击.
因此, 评估 IDS 背后的主要思想是鉴定有多少这样的数据对象被正确和错误地标记了.

为了评估 IDS 系统的质量, 我们首先需要定义一些条目.
当 IDS 在检测网络流量或事件时, 它试图判断流量或事件是否是恶意的.
当 IDS 指出一个入侵, 称之为Positive.
如果相应的警报确实是一个真正的入侵企图, 那么我们有一个True Positive (TP), 
即来自 IDS 的阳性断言是可信的, 因为这是一个正确的断言.

然而, IDS 可以即使没有发生攻击也报告入侵.
在这种情况下, 我们有所谓的误报(FP).
定义(True Positive)真阳性是真实的警报, 是对入侵企图的响应.
这表明入侵检测系统精确地检测到了一个特定的攻击.

**定义(False Positive)**误报是一个错误的警报, 是对非恶意行为响应, 即在没有发生攻击的情况下被 IDS 识别为入侵的错误事件.
表示尽管没有发生真正的攻击, 入侵检测系统却检测到攻击.
另一方面, 如果 IDS 指明流量或事件是无害, 这叫一个negative.
当 IDS 指明没有入侵而这是一个正确的断言时, 称为True Negative(TN).
相反的, 当 IDS 没有指出入侵, 但实际存在入侵行为时, 我们有一个False Negative (FN).

**定义(True Negative)**是当没有入侵行为发生时也没有警报的事件.
这表明入侵检测系统没有错误地检测正常情况.

**定义(False Negative)**是当一个真正的入侵行为发生时没有入侵警报发出的事件,
即当入侵发生时 IDS 无法识别的事件.

**定义 IDS 的(True Positive Rate)**真阳性率(TPR)或的检测率(DR)为: TPR = TP/(TP +FN)
其中 TP 是真阳性的数量，FN 是假阴性的数量.
完美的 IDS 是使得 TPR = 1.
TPR衡量了恶意事件被正确识别和报告的数量.

**定义(False Positive Rate)**误报率为: FPR = FP/(FP+TN).
其中 FP 是误报数，TN 是
真阳性的数量.
误报率 (FPR) 衡量的是被错误分类和报告为入侵的合法事件的量。

#### 2.1.2 ROC曲线

接受者操作特征(ROC)曲线通常用于评估 IDS 的质量
(参见[7]和[8]有关更多关于 ROC 曲线分析信息).

ROC曲线是对信号检测器准确性的二维描述, 它产生于一组给定的测试数据.
需要两个维度来展示真阳性检测率随着假阳性率的增加而降低的整个过程.
ROC曲线的目的是表明相应信号检测器的精度. 

以曲线形状展示的精度信息是二维的, 这是因为有两种事件，因此有两种
可能的准确性.

第一个维度是检测信号事件的成功率, 沿y轴显示(纵轴).
第二个维度是错误识别噪声事件的错误率, 沿x轴显示(横轴).

因为成功是好的, 错误是坏的, 
一个好的ROC曲线的y值应该以比x值其更快的速率增长, 从而曲线形状迅速抬升.

之后, 随着决策门槛的变得越来越放宽, 噪声的误差值(x值)也必须
变大, 赶上信号的成功值(y值).
这使得曲线向右弯曲, 直到它触及点(0, 1)[7].

伴随着阈值的变化多样, IDS的ROC曲线基本上是TPR和FPR率之间的图表, 以显示
它们之间的权衡.

它是通过调整IDS以平衡假阳性(FP)与真阳性(TP)而获得，
其中ROC曲线上的每一个点对应在确定灵敏度参数(阈值)下计算得出的固定量的TPR和FPR.

ROC曲线提供了一种紧凑而简单的方式来直观地理解
如何平衡众多阈值取值. ROC曲线形状的抬升指明了检测器的精度.

在图2.1中, (a)显示了一条完美的ROC曲线, 它穿过点(0, 1),
而ROC曲线并不比正对角线更好.

如图2.1(b)所示, 沿ROC曲线的每一个点对应不同的阈值.
靠近原点的点(0, 0)表示更排他性的标准, 
点更接近右上角(1, 0)表示更具包容性(来源[7])

![](./papers/figures/2.1.jpg)

### 2.2 IDS分类

Debar等人[9]第一个对入侵检测系统进行了系统的分类(后来在[10]中进行了修订).
Axelsson[11]贡献了对IDS的综合调查和分类, 更深入地解决了某些方面, 即检测原理.
在本节中, 我们介绍IDS的分类, 包括基于主机和网络以及基于特征和异常的方法.
我们介绍基本定义, 通过比较不同的方法讨论它们典型的优缺点, 并列出一些实际系统的例子.

#### 2.2.1 基于数据源的IDS特性

IDS可以根据它监控的活动类型进行分类, 更具体地说, 是根据用于构建其检测模
型的数据来源进行分类.
通常, 此分类有两类, 基于主机或者基于网络.

##### 2.2.1.1 基于主机的系统

三十年来, 入侵检测一直是一个活跃的研究领域.
1980 年, Anderson[12]发表了一篇有影响力的论文, 
题为"计算机安全威胁监测和监视", 随后Denning[13]于1987年提出了早期典型IDS的抽象模型,
启发了学术界并且是当今许多现有IDS产品的催化剂.

这些最早形式的程序侧重于通过审查系统审计日志和记帐文件来发现安全事件——类似于许多现代日志分析器.
根据Mukherjee等人[14]的调查, 从那时起, 许多此类IDS开始被设计和应用.
之后这些程序通过不断添加实时日志监控和更精细的系统检查而发展改进, 逐步成为当前最常见的一些基于主机的入侵检测系统(HIDS)。

基于主机的IDS(HIDS)监控单个主机(或应用程序)并审核由托管操作系统(OS)或应用程序跟踪的数据
, 例如像系统日志或资源使用情况等等这些. 
OSSEC1是这类HIDS一个被熟知的例子.
然而, 由于Internet的发展和现代操作系统的复杂性增加,
HIDS不再像以前那样流行, 因为很难实现对被监控系统的完全覆盖.
由于HIDS通常在共同的硬件上运行, 与被监视的实际系统或应用程序共享相同的资源, 
因此最终对整个系统性能的影响也使得这种IDS不太受欢迎.

表格2.1总结了基于主机的IDS的优势和劣势

|        |       |
|  ----  | ----  |
| 优点 | 不用涉及网络, 可检测本地攻击|
|              | 可以监控和分享应用程序或者操作系统正在发生着什么|
|              | 不需要新添加用于安装的硬件 |
| 缺点 |必须安装在需要监控的每一台主机上 |
|                |会影响并最终削弱系统性能 |

表2.1 基于主机IDS的优缺点

##### 2.2.1.2 基于网络的系统

此后, 我们见证了基于网络的入侵检测系统(NIDS)的诞生和推广,
, 它主要是对捕获数据应用一些规则和过滤的数据包嗅探器,
能够标记那些本质上似乎是恶意的数据包.
NIDS可以被认为是抵御针对计算机系统和网络攻击的有效的第二道防线[15].
由于越来越多来自Internet的基于网络的攻击的严重性和可能性,
现在几乎所有的大型IT基础设施都实施了NIDS[3].

基于网络的IDS(NIDS)监控网段并分析流经它的流量.
网络入侵检测系统由原始网络流量的解释驱动.
它们检查网络上传输的实际数据包的内容并解析这些数据包,
分析网络上使用的协议并提取相关信息.
这通常可以通过被动监听网络并捕获被其他机器传送的数据包的副本来实现.

被动网络监控利用混杂模式接入,
混杂模式的网络设备或嗅探器
从直接来自网络媒体的数据包中获取副本, 
而无论其目的地是哪里(普通设备只读取发送给它们的数据包).

然后NIDS尝试通过观察流量中的可疑模式来检测攻击.
它们通常善于辨别涉及对网络进行低级别操纵的攻击.
这种类型的IDS还可以轻松关联针对一个网络上的多台机器的攻击[16].

NIDS的主要优势在于它们能够在不影响主机性能的情况下监控数据和事件.
无论如何, 即便是可获取巨量信息, NIDS仍缺乏确定计算机系统内部究竟发生了什么的能力, 这是他们的主要缺点.
例如, 除非加密密钥可供它们使用, NIDS才能正确分析使用数据加密的应用程序或协议.

表格2.2 列出了基于网络IDS的优点和缺点

|        |       |
|  ----  | ----  |
| 优点 | 可以同时监控多台主机|
|              | 可以将多台主机攻击行为进行关联|
|              | 不影响主机性能 |
|              | 可以检测到在主机本地无法观察到的攻击|
| 缺点 |处理性能必须能够跟上网络速度|
|                |在加密通道情况下会有些问题|
表2.2 基于网络的IDS的优缺点

被熟知的两个经典的NIDS的例子是Snort2和Prelude3.

#### 2.2.2 基于入侵模型的IDS特性

##### 2.2.2.1 基于特征的系统

基于特征的IDS(也称为基于误用检测), 例如Snort[17], 
包括一个已知攻击的特征数据库, 其工作方式与防病毒软件非常相似, 当它在其数据库中匹配到攻击时会发出警报.
这些特征(也称为规则)通常是针对广泛使用的系统或应用程序中已存在并被公布的安全漏洞.
然而与反病毒软件在没有可用特征或病毒库已过期时无法识别未知病毒类似,
基于特征的IDS也无法检测到未知攻击。

由于特征是专门为匹配已知攻击而设计的, 因此这种类型的IDS通常具有非常低的误报率.
然而, 同样由于特征的特定性和静态性, 基于特征的IDS不太可能检测到已知攻击的哪怕是轻微的修改.
这是一个严重的缺点, 因为在特征数据库更新之前, IDS不会检测到零day攻击和多态攻击(攻击负载的变化不会
影响攻击效果).

基于特征的IDS 对零日攻击无效, 因为这些攻击是未知的, 因此, 预先不存在与它们完全匹配的特征.
鉴于新的攻击经常出现(即便不是每天), 在第一次检测到新攻击的时间和为其准备好特征的时间之间通常存在时间间隔
(首先必须有人编写特征，然后IDS管理员添加它到他们的特征数据库),

这意味着系统在此期间内都暴露在攻击之下, 
从而为攻击者提供了获得系统控制权的机会窗口.

由于Web流量的动态性和即时性, 此限制严重削弱了基于特征的IDS检测针对Web服务器和应用程序的攻击的可用性.

基于特征的系统的一个例子是ModSecurity, 一个网络应用程序防火墙(WAF),
它作为Apache Web服务器的一个模块运行, 
意图为网络应用程序中经常发现的未知漏洞提供通用防护(在大多数情况下是自定义编码的), 但它仍然依赖于规则(特征).

##### 2.2.2.2 基于异常的系统

为了克服基于特征的系统无法检测到以前未知的攻击的固有局限性, 
研究人员已经寻求其他方法来检测入侵, 即使用基于异常的方法.

基于异常的IDS的工作原理是建立一个关于使用模式的统计模型, 该模式描述了被
监控资源的正常使用行为(无非是在其正常运行期间观察到的一组特征). 
我们通常将这个过程定义为训练阶段.
然后, 也就是在创建了关于正常和预期行为的统计模型后,
系统使用相似性度量将新输入请求与模型进行比较, 
并对那些显著偏离的请求产生警报, 
认为它们是异常行为.
基本上, 检测到攻击是因为它们产生了统计上不同的行为, 即异常行为, 与创建模型时观察到的行为不同.

异常检测假定入侵与用户或应用程序表现出的异常行为高度相关. 
基本思想是为被监控对象的正常行为设定基线, 然后将与基线显着不同的行为标记为异常或可能的入侵[18].

基于异常的系统的主要优点是它能够在以前未知攻击(或修改过的已知攻击)发生时立即检测到.
基于异常的系统能够检测到绕过基于特征的系统的新型攻击, 
而该攻击信息以后可用于为基于特征的系统开发新规则. 
因此, 结合使用IDS方法(基于特征和基于异常的方法)可以确保覆盖范围更广攻
击检测, 以及使特征数据库保持更新.

不幸的是, 现在使用的大多数IDS仍然是基于特征的, 很少有基于异常的IDS在生产环境中实施, 
这主要是由于基于特征的IDS更容易实现, 配置更简单, 维护它们需要的工作量更少.

在受监控资源不稳定且经常变化的情况下, 如Web应用程序,
基于异常的IDS的高误报率一直是削弱它的接受度和流行度原因.
如果统计模型过于严格, 系统无法概括和解释变化, 则很可能会产生许多误报.
尽管如此, 已经存在多种采用异常检测机制的产品.

与Web相关的基于异常的IDS的实例是一些Web应用程序防火墙.
这些产品使用基于异常的技术来检测针对Web的攻击.
Artofdefence Hyperguard 和F5 BIG-IP Application Security Manager 是采用此类技术的两种现有商业产品.

表2.3 显示了基于特征与基于异常的入侵检测的一些优点和缺点之间的比较.

|检测模型|优点|缺点|
| ---- | ---- | ---- |
|特征|低误报率|无法检测到新的以前未知的攻击| 
||无须训练模型|需要持续更新特征数据库|
||报警典型化和类别化|对定制化的资源调整困难|
|异常|能够检测到新的以前未知的攻击|比较倾向误报| 
||自学习|报警没有分类和典型性| 
|||需要训练模型| 
表2.3 签名与基于异常的系统的优缺点.

### 2.3 IDS的角色和要求

McHugh等[19]发表了一篇简明的论文, 描述了入侵检测技术在整体安全架构中应该扮演的角色, 并强调了入侵检测系统的重要性.
理想情况下, IDS应该能够检测, 报告和防止范围广泛的安全事件, 包括入侵和渗透尝试, 执行未经授权的特权程序, 未经授权的网络连接和其他相关安全问题.
理想的IDS应该能够实时执行其操作, 抵御拒绝服务攻击, 检测已知和未知的入侵方法, 并且不产生误报.

仍然没有可以符合所有这些特性的IDS, 但是有一些可以将其中一些参数优化得非常接近理想.
此外, 通过混合使用基于特征和基于异常的IDS的方法, 可以实现更多这些特性.
根据Crosbie和Spafford[20]的说法, IDS应该解决以下问题, 无论它基于什么机制:

* 它必须在无人监督的情况下连续运行. 系统必须足够可靠地在被观测系统的后台运行. 但是它不应该是一个"黑匣子". 也就是说, 它的内部运作情况应该可以从外部进行检查.
* 它必须是容错的, 这意味着它必须能够经受住系统崩溃, 并且不会在重新启动时重建其知识库.
* 与上文类似, 它必须抵御破坏. 系统可以自我监控以确保它没有被破坏.
* 它对系统的负载开销应该微小. 一个把计算机拖慢得像爬行一样的系统根本无法使用.
* 它必须能观察与正常行为的偏差.
* 它必须很容易地适应所要考虑的系统. 每个系统都有不同的使用模式, 防御机制应该很容易适应这些模式。
* 随着新应用程序的添加, 它必须随着时间的推移应对不断变化的系统行为. 系统配置文件会随时间变化, IDS必须能够适应.
* 最后, 它必须应该很难被欺骗.

### 2.4 万维网和HTTP协议

万维网, 缩写为WWW, 通常称为Web, 是一个通过互联网访问的相互链接的超文本文档系统.
使用Web浏览器, 可以浏览包含文本, 图像, 视频和其他多媒体的网页, 并使用超链接在它们之间导航.
使用早期超文本系统的概念, Berners-Lee和Cailliau[21]于1989年3月在日内瓦的CERN写了一份提案,
使用"用户使用超文本链接和访问存储各类信息的节点网络".

超文本传输议(HTTP)是RFC2616互联网标准[22]中描述的一种无状态网络协议, 
自1990年以来一直被万维网全球信息倡议使用.

与许多网络协议一样, HTTP 使用客户端-服务器模型, 其中 HTTP 客户端打开连
接并向 HTTP 服务器发送请求消息, 然后 HTTP 服务器返回响应消息, 通常包含
所请求的资源. 传递响应后, 服务器关闭连接(因为它的无状态性质, 即不维护事务之间的任何连接信息).
客户端可以是浏览器(例如Mozilla或IE)或网络机器人(例如Google bot).

```
GET /example.html HTTP/1.1
Accept: */*
Accept-charset: ISO-8859-1,utf-8
Accept-encoding: gzip,deflate
Accept-language: en-us,en;q=0.5
Connection: keep-alive
Host: example.org
Referer: http://example.org/index.html
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en-US; rv
   :1.9.2.10) Gecko/20100914 Firefox/3.6.10
```
图2.2: Mozilla浏览器中HTTP请求的例子

```
GET / HTTP/1.1
Host: example.org
User-Agent: Googlebot/2.1 (+http://www.google.com/bot.html)
Content-Type: text/html
Connection: close
```
图2.3: Google Bot的HTTP请求的例子

请求的资源可以是路径或文件名, 必须经由Web服务器解释.
某些路径旨在由程序解释, 例如 RFC 3875 [23] 或 PHP 中描述的通用网关接口 (CGI) 脚本.

服务器端解释脚本的使用允许网站从早期和非常静态的纯 HTML 内容演变为动态内容,
如今为用户提供完全不同的更丰富的网站浏览体验.
通常, 脚本的路径是所请求资源路径的一部分, 参数跟在路径中的?后面, 采用 key=value 的形式, 
当有多个参数要传递给脚本时, 用 & 分隔.
图2.4例子展示, 资源为/example.php, 有两个参数, user值为johndoe, id值为1.

```
GET /example.php?user=johndoe&id=1 HTTP/1.1
Host: example.org
User-Agent: Mozilla/5.0 Gecko
Accept: text/xml, image/png, image/jpeg, image/gif, */*
Cookie: PHPSESSID=7dd1d5d1471fa8be2fea8f163cce3257
```
图2.4: 请求PHP脚本并传递参数的例子

#### 2.4.1 HTTP请求结构

HTTP请求是发送到 Web 服务器的文本行(由 CRLF 分隔)的集合, 其中包括请求行, 请求头字段和请求体.
请求行由三部分组成, 以空格分隔, 指定为: 被实现的方法名称, 请求资源的本地路径和使用的协议版本.
方法是出现在 HTTP 请求中的第一个词,
大多数 HTTP 请求是 GET 类型, 但也存在其他类型, 例如 POST 或 HEAD.
方法名之后是资源路径 (URI), 通常以文件, 文件系统中的目录或两者的组合来表示.
最后一部分, 指明客户端使用的协议版本(一般为 HTTP/1.0 或 1.1).
一个典型的请求行如图 2.5 所示：

```
GET /path/to/file/index.html HTTP/1.1
```
图2.5: 请求行例子

在 HTTP 请求的初始请求行之后, 有请求头字段, 它提供有关请求的信息.
请求头字段行采用通常的文本标题格式, 即: 每一行请求头字段格式为"Header-Name: value", 以 CRLF 结尾. 
HTTP 1.0 [24] 定义了 16 个请求头, 但没有一个是必须的.
HTTP 1.1 [22] 定义了 46 个标头, 其中一个(Host:)是必须的.
请求头是可选行的集合, 允许附加有关请求和/或客户端(浏览器, 操作系统等)的附加信息.
每一行都由一个描述请求头类型的名称组成, 后跟一个冒号(:)和请求头的值.
图2.2 展示了一个具有多个请求头行的 HTTP 请求的结构例子.

最后是请求主体, 它是在请求头之后立即传输的数据字节.
请求体是可选行的集合, 必须用空行将其与前面的行分隔开, 例如在
使用 HTML 表单向服务器发送数据时, 通过 POST 命令发送数据.

在我们的实验中, 我们只考虑使用 GET 方法的请求, 因此我们没有深入请求体中.
但是请注意, 涵盖 POST 请求, 解析请求体以执行我们在第4章中介绍的相同分析是很简单的.
我们没有这样做, 主要是因为我们已经在处理大量数据, 但这是为未来的工作所计划的.

### 2.5 Web漏洞

多年来, 开放Web应用程序安全项目(OWASP)一直在跟踪和研究Web漏洞的趋势, 
并定期发布有关该主题的调查结果.

表2.4 显示了2010年OWASP公布的前10个Web漏洞[25], 按它们对组织机构的风险排名.
OWASP 使用的风险排名方法包含并考虑了多个因素, 例如威胁代理, 攻击向量, 安全弱点, 技术和业务影响.

|  排名  | 漏洞  |
|  ----  | ----  |
|  1  | 注入  |
|  2  | 跨站脚本(XSS) |
|  3  |损坏的身份验证和会话管理
|  4  |不安全的直接对象引用|
|  5  |跨站请求伪造 (CSRF)
| 6   |安全配置错误 |
|  7  | 不安全的加密存储  |
|  8  | 未能限制 URL 访问|
|  9  | 传输层保护不足|
|  10  | 未经验证的重定向和转发|

表2.4: OWASP 应用程序安全风险前10名 - 2010.

现在我们简要解释一下OWASP的排名前十漏洞[25]:

**1-注入** 注入缺陷发生在不受信任的数据被传送作为查询语句的一部分提交给解释器的时候, 这导致执行意外的命令或者访问非授权数据.

**2-跨站脚本(XSS)** 每当应用程序在没有正确验证和转义的情况下向 Web 浏览器发送不受信任的数据时, 就会出现 XSS 缺陷.
这种类型的缺陷允许攻击者在受害者的浏览器中执行脚本, 这些脚本可以劫持用户会话, 破坏网站或将用户重定向到恶意网站(例
如网络钓鱼或恶意软件).

**3-破坏身份验证和会话管理** 与身份验证和会话管理相关的应用程序功能经常没有正确实现, 这使得攻击者可以破坏密码, 密钥, 会话令牌或利用其他实现缺陷来冒充其他用户的身份.

**4-不安全的直接对象引用** 当直接引用内部实现对象(如文件、目录或数据库密钥)时, 在没有访问控制检查或其他保护机制的情况下, 攻击者可以操纵这些引用来实现访问未经授权的数据.

**5-跨站请求伪造(CSRF)** CSRF攻击强制登录受害者的浏览器向易受攻击的 Web 应用程序发送伪造的 HTTP 请求, 包括受害者的会话 cookie
和任何其他自动包含的身份验证信息.
这让攻击者强制受害者的浏览器生成会被易受攻击的应用程序认为是来自受害者的合法请求.

**6-安全性错误配置** 良好的安全性需要为应用程序, 框架, 应用程序服务器, Web服务器, 数据库服务器和平台定义和部署安全配置.
因为许多设置没有附带安全默认值, 所有这些设置都应该被定义, 实施和维护.
这包括使所有软件保持最新状态，也包括应用程序使用的所有代码库.

**7-不安全的加密存储** 许多网络应用程序没有通过适当的加密或散列来正确保护敏感数据, 例如信用卡, SSN 和身份验证凭据.
攻击者可能会窃取或修改此类保护薄弱的数据,以进行身份盗用, 信用卡欺诈或其他犯罪.

**8-未能限制URL访问** 许多Web应用程序在呈现受保护的链接和按钮之前检查URL 访问权限.
然而每次访问这些页面时, 应用程序都需要执行类似的访问控制检查, 否则攻击者将能够伪造 URL 以访问这些隐藏页面.

**9-传输层保护不足** 应用程序经常无法验证, 加密和保护敏感网络流量的机密性和完整性.
当他们这样做时, 他们有时会支持弱算法, 使用过期或无效的证书, 或者没有正确使用这些技术.

**10-未经验证的重定向和转发** Web 应用程序经常将用户重定向和转发到其他页面和网站, 并使用不受信任的数据来确定目标页面. 
如果没有适当的验证, 攻击者可以将受害者重定向到网络钓鱼或恶意软件站点, 或者使用转发来访问未经授权的页面.

### 2.6 针对Web服务器和应用程序的攻击

针对 Web 服务器或应用程序的攻击可以高度多样化, 无论是它们所针对的特殊性还是它们所呈现的形式.
通常, 迄今为止看到的大多数攻击都集中在资源路径上, 只有少数攻击针对请求的其他部分.
针对 Web 服务器或应用程序的攻击的多样性很高, 这说明了程序员在代码中引入的错误数量.

Alvarez 和 Petrovic [26] 使用攻击生命周期的概念为 Web 攻击提供了分类法,
即攻击者在 Web 服务器上执行某些恶意活动所遵循的一系列步骤. 图2.6(来源[26])说明了该步骤的顺序：

图2.6: Web 攻击的分类
1. 切入点: 攻击通过的地方.
2. 漏洞: 系统中允许未授权操作的弱点.
3. (受威胁的)服务: 受到攻击威胁的安全服务.
4. 行为: 对暴露漏洞的Web服务器进行的实际攻击.
5. 长度: 传递给HTTP请求参数的长度。
6. HTTP元素: 执行攻击所需的方法和头部字段.
7. 目标: 攻击的目标.
8. 范围: 攻击对Web服务器产生的影响.
9. 权限: 攻击者成功完成攻击后获得的权限.

鉴于执行 Web 攻击通常遵循的这一系列步骤, 我们现在简要描述一些最常见的针对 Web 应用程序的攻击类别.

#### 2.6.1 SQL注入

SQL 注入是这样一类攻击, 利用未经处理的用户输入更改 SQL 查询语句的结构, 在执行时对数据库产生意想不到的影响[27].
这种类型的攻击之所以成为可能, 是因为 SQL 查询语句通常由一系列常量字符串和字符串变量拼接而成.
如果在创建查询时使用的那些变量在用户的控制之下, 他或她可能能够以不希望的方式改变查询的含义.
考虑这样一个基于 Web 的应用程序示例, 该应用程序允许用户列出他所有注册的给定类型的信用卡(取自 [27]), 伪代码可能如图 2.7 所示.

```
uname = getAuthenticatedUser()
cctype = getUserInput()
result = sql("SELECT nb FROM creditcards WHERE user=’" + uname +
   "’ AND type=’" + cctype +"’;")
print(result)
```
图2.7: 说明SQL注入漏洞伪代码示例

如果用户 Bob 搜索了他所有的 VISA 卡, 将执行以下查询:
```
SELECT nb FROM creditcards WHERE user = 'Bob' AND type = 'VISA';
```

此示例代码包含一个 SQL 注入漏洞, 因为 Bob 可以操纵 SQL 查询的结构来查
看属于用户 Alice 的所有信用卡, 只需请求类型为 ’ OR user =’Alice 的信用
卡列表. 攻击查询如下：
```
SELECT nb FROM creditcards WHERE user = ’Bob’ AND type = ’’ OR user = ’Alice’;
```

该查询将向攻击者返回 Alice 的信用卡列表, 因为用户输入未经过处理.
上面显示的应用程序的正确实现不应允许用户提供的数据更改查询的结构.
SQL 查询的用户提供的部分永远不应被 SQL 服务器解释为 SQL 关键字, 表名, 字段名或运算符.

SQL 查询的其余部分, 我们将称为常量, 由带引号的字符串和数字组成.
在将用户提供的字符串用作常量之前, 必须确保在将所有引号插入SQL查询语句之前对所有引号进行转义.
同样, 也必须检查用户提供的数字, 以验证它们是数字而不是字符串.
在上面的示例中, SQL 注入攻击是可能的, 因为字符串cctype在插入查询语句之前没有正确转义。

#### 2.6.2 跨站脚本 - XSS

当 Web 应用程序从用户那里收集到恶意数据时, 就会发生跨站点脚本(XSS)攻击, 这些恶意内容通常以超链接的形式存在.
用户很可能会从另一个网站, 即时消息或只是通过阅读论坛帖子或电子邮件单击此链接.

存在三种不同类型的跨站点脚本攻击, 即反射XSS(或非持久化), 存储XSS
(或持久化)和基于DOM的XSS(文档对象模型).

XSS攻击通过将脚本(通常是嵌入在 HTML 代码中的 JavaScript)注入不受攻击者控制的服务器来利用 Web 服务器和 Web 浏览器之间的信任关系.
一般来说, 跨站脚本攻击(我们这里以存储型XSS攻击为例)的工作原理如下:
首先, 攻击者将包含 JavaScript 代码的 HTML 代码上传到 Web 服务(例如Web 服务器论坛), 如图所示.
接下来, 恶意脚本将在受害者的浏览器中执行,
由于该脚本源自 Web 服务器, 因此它的运行权限与源自服务器的合法脚本相同.
假设受害者与托管 Web 服务器的域有信任关系(通常是这样), 恶意脚本可以访问与该域关联的敏感数据.

```
<a href="http://www.legitsite.com/forum/error.aspx?err= <script>document.location.replace( ’http://www.hackersite.com/HackerPage.aspx?Cookie=’ + document.cookie); </script>">点击这里查看最近的帖子</a>
```
图2.8: XSS攻击代码示例

这种类型的攻击通常用于窃取用户的登录凭据或其他个人信息.

#### 2.6.3 远程文件包含 - Shellcode注入

远程文件包含(RFI)是一种用于利用 Web 应用程序中的动态文件包含机制的攻击技术.
当 Web 应用程序获取用户输入(URL、参数值等)并将它们传递到文件包含命令时, 

Web 应用程序可能会被诱骗包含带有恶意代码的远程文件. 
RFI可用于在服务器上运行恶意代码, 这可能导致严重的系统危害, 以及通过操纵发
送的响应内容(例如通过嵌入恶意 javascript 代码来窃取客户端会话 cookie)
在客户端上运行由服务器返回给客户端的恶意代码.

这种类型的攻击很危险, 因为它允许在 Web 服务器中执行远程代码, 例如shellcode 注入攻击, 通常利用缓冲区溢出漏洞(请参阅 [28] 了解详细说明).

### 2.7 Web攻击异常检测的问题

许多现有的 IDS 解决方案, 例如 Snort [17], 都有检测 HTTP 攻击的规则.
然而, 这些规则非常有限, 主要是因为 HTTP 是 IDS 处理起来困难且有挑战性的协议.

这些挑战包括:
* HTTP 的无状态特性
* 网络服务器的不稳定特性
* HTTP 请求的长度差异性大
* 在没有攻击的情况下, 进行异常检测的训练数据很难获得
* 正常互联网网络流量中存在"无害"攻击, 因此 IDS 应该允许它们而不产生报警, 但仍然能够检测到新的攻击
* 由于 HTTP 是无状态的, IDS 不能依赖请求之间的顺序关系, 事实上，大多数现有攻击只有一个长请求

由于可用于执行这些攻击的僵尸网络的存在, 攻击者和合法用户可能正在使用同一台计算机.
因此, Web 服务器异常检测方法必须能够分析孤立的事务请求并确定它们是否代表对服务器的攻击.

除了 HTTP 的无状态性质外, 网站内容也经常变化. 报纸网站, 每天都在改变他们的新闻和头条新闻.
在 Internet 上销售产品的网站不断添加新产品和删除过时产品. 
拥有个人博客的用户经常添加新条目.
为了成功检测, 任何 IDS 都必须能够应对这种动态和非静态环境.

### 2.8 Web应用程序的异常检测

在过去的十年中, 已经提出了几种基于Web的异常检测技术. 所有这些技术都基于 HTTP, 
这意味着对正常行为的建模是通过观察直到HTTP层的解码网络帧, 或通过充当反向 HTTP 代理来构建的.

基于异常的检测器使用这些技术来保护 Web 应用程序, 最初是在 [29] 中提出的, 
作者在其中描述了一个使用贝叶斯参数估计来分析 Web 访问日志并检测Web 应用程序中的异常会话的系统.
他们的技术假定恶意行为表现在 HTTP 请求的参数中, 这是形成这项研究成果的基本思想.

在 [30] 和 [31] 中，提出了许多不同的异常检测技术来检测针对 Web 服务器和Web应用程序的攻击.
这些技术侧重于分析 HTTP 请求中的参数, 基本上由不同检测模型的组合组成, 
即属性长度, 属性字符分布, 结构推断, 令牌查找器, 属性存在与否以及属性顺序.
本论文的一个重要部分依赖于 Kruegel和 Vigna [30] 提出的模型.

Wang 和 Stolfo [32] 提出了一种基于异常负载的网络入侵检测系统, 
该系统使用马氏距离作为检测具有多个属性的数据集中的异常请求的一种方式,
根据每个变量的标准差和协方差缩放每个变量, 并考虑测量的属性相互之间发生变化.

Robertson等人的方法[33], 建议使用启发式方法来推断基于 Web 的攻击类别.
它试图通过使用泛化和表征技术来解决基于异常的入侵检测系统的局限性.
通过使用泛化, 可以创建对异常的更抽象的描述, 从而使人们能够对类似的攻击进行分组.
至于特征, 它用于推断与一组异常相关的攻击类别.

王等[34], 提出了一种基于 n-gram 分析的内容异常检测器,
它使用布隆过滤器并提供对模仿和多态攻击的抵御.

至于英厄姆等人[35], 展示了如何使用 DFA 归纳算法结合自动机规约启发式算法构建系统, 该系统可以通过避免过度概括来最小化误报风险.
它描述了一种能够处理任意长度的非平稳数据的学习算法.

在 [36] 中, 比较了 HTTP 异常检测技术, 而在 [37] 中，提出了一种设计精确异常检测系统的方法, 
并展示了如何将其应用于检测恶意 Web 请求的问题.

接下来, 在 [38] 中, Ingham 进行了全面研究并比较了现有的 HTTP 入侵检测异常检测方法,这是对我们工作最有影响的参考.
在他的研究中，他提出了两种新的基于语法的异常检测模型: DFA 和 n-grams, 
描述了一个用于测试异常检测算法的框架, 并使用来自四个不同网站的数据展示他的发现.

在 [39] 中, Bolzoni等人提出了一种基于异常的网络入侵检测系统, 后来在[40]中与其他方法进行了比较.
[41]提出了一种基于异常的网络入侵检测系统.
接下来, 在[42]中, 作者提出了一个系统来减少由基于异常的系统引起的误报. [43]中详细介绍了所有这些研究.

Vigna 等人[44]提出了一种技术, 通过结合使用 Web 请求异常检测器和SQL 查询异常检测器来提高基于 Web 的入侵检测系统的检测率.
他们还尝试通过一个异常驱动的反向代理来减少误报, 
该代理根据与Web请求相关联的异常分数提供对网站的差异化访问.

克里斯乔内等[45], 提出了一个异常检测器, 它对 HTTP 响应和文档对象模型 (DOM) 进行建模,
以增强针对 SQL 注入和 XSS 攻击的检测能力.

最近, Song 等人[46]，提出了一种基于机器学习的统计工具, 用于防御网络层代码注入攻击.
这种方法利用马尔可夫链的混合在 HTTP 层对合法有效载荷进行建模, 并推导出相应的训练算法.

Maggi等[47]解决了异常检测背景下 Web 应用程序概念漂移的问题, 
而Robertson 等人[48]表明, 训练数据稀缺可以在基于网络的异常检测系统中通过使用有效训练, 配置稳定的全球知识库来克服.

本论文使用了先前在[30, 32, 36, 38] 中提出的几种基于异常的入侵检测技术.
然而, 它的目的是为一个真正相当复杂的 web 应用程序提供 IDS, 因此我们不仅实现了其中的一些技术,
而且研究了获得良好训练数据的问题, 并且不得不处理在之前的这些工作中没有考虑的几个实际问题.
