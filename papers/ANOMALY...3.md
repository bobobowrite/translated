# 基于Web攻击的异常检测

Gustavo Miguel Barroso Assis do Nascimento

MESTRADO EM SEGURANÇA INFORMÁTICA

November 2010

## 3 Web攻击的异常检测

我们研究的主要目标是评估使用针对生产环境大规模部署的Web应用程序的基于异常的IDS.

在本章中, 我们从讨论泛化的概念和其在异常检测中的重要性
以及如何创建异常检测模型开始.
然后, 我们提出一种算法, 可用于清理从应用程序的真实流量中获得请求(因此
可能包含攻击)所形成的数据集, 以消除包含在其中的异常请求,
目的是生成一个不含攻击的数据集, 可安全地用于训练异常检测系统.

此外, 我们解释了如何使用相似性度量来检测异常. 
然后我们描述了之前的检测网络流量异常文献中提到的九种不同的算法并讨论
他们的优点和局限性.

然后进一步我们提出一种涵盖所有这些算法的基于异常的入侵检测系统, 以及我们所使用的
用于减少误报并提高其准确性的泛化启发式方法.

### 3.1 泛化

入侵检测的行为模型通常是从受保护资源的知识构建的.
因此, 模型的质量是由知识以及用于构建它的技术所决定.

现实中大多数情况很难保证知识的完备性,
因为我们无法预知对一个计算资源的未来的行为.

考虑正常使用计算资源行为的不完整性, 
模型生成用于推断除了已知和
观察到的行为外更多的行为([10], [49], [50], [51]).

原则上, 模型泛化可以提高IDS的检测率, 但也可能降低其检测性能.
因此, 模型泛化和检测性能之间的关系对入侵检测至关重要.

一般来说, 泛化正常行为模型是有用的, 以便更多正常行为可以被识别.
然而, 模型泛化可能导致模型不准确, 
而它也不能完全解决不完整性问题,
大多少场景它推断出的是部分而不是全部的未知行为.

在第 3.7 节中, 我们解释了我们如何解决泛化问题,
特别是我们如何使用泛化启发式方法来达到提高 IDS 整体准确性的目标.

### 3.2 模型生成

在训练阶段拥有良好的数据集是实现系统的准确性和有效性的一个至关重要的方面.
基于异常的系统所使用的模型应该反映系统在
正常情况下(即没有攻击存在)的行为.
否则在检测阶段, 系统可能无法识别攻击并将其归类为正常.
由于这个事实, 系统应该用干净的(即没有攻击)数据集.
然而, 实际上这样的数据集是难以获得, 因为捕获的网络流量中必然包含攻击尝试,
它捕获的流量越多, 这种机率就越大.
因为基于异常的系统需要干净的训练数据集而迄今还没有简单的方法来获得,
这就产生了一个问题，
处理这个需要依靠具备安全专业知识的安全管理员分析其中的大量内容来完成.
因模型需要定期更新以应对和适应网络应用程序的变化,
这个过程变成了一个非常人力密集和耗时的任务, 并极大可能地包含着(人为)错误.
因此, 人工检查可以辅以自动手段, 
例如通过使用像 Snort 这样基于特征的系统检测数据集，
它可以预处理训练数据并检测一些众所周知的攻击, 如扫描, 旧漏洞利用等.
无论如何, 基于特征的系统将无法检测到训练数据中的所有攻击.
两个不同的因素必须在整个训练阶段考虑.
首先, 它应该持续足够长的时间, 以让系统构建一个值得信赖的
模型, 而不是有一个非常短的训练阶段导致拥有一个非常小的模型, 而无法捕捉到
相关应用程序或网站的正常行为.
在检测阶段，很可能有很多合法请求被错误地标记为异常(误报).
然而, 较长的训练阶段势必会将大量噪声引入到模型中.
另一方面, 当今的Web 应用程序是非常动态并且经常变化, 
所以这可能表明每次应用程序中的更改会转化为对应用程序正常输入的显着变化,
于是必须重建系统和再训练模型.
训练集越大越难维护这样的IDS.
因此, 这里我们概述一下模型生成所需的一些属性:

* 模型的质量是实现高检出率和低误报以及低漏报的基础
* 为避免误报, 模型应包含所有可能的非恶意输入
* 为避免漏报, 模型不应包含任何可能的攻击
* 模型应该易于构建, 构建可信模型所需的训练阶段越短越好

### 3.3 清洗数据集的算法

我们提出的这个算法的目标是定义一组用于训练 T 的没有异常流量(即没有攻击)的请求.
通常, 获取用于训练的不包含攻击的数据是困难的, 在第1.1节和第3.2节中, 我们描述了拥有此类数据与训练基于异常的入侵检测系统的相关性.
我们的算法称为Sanitize-Dataset, 因为它的目的是转换(清理)给定的请求数据集, 以删除那些异常的请求.

从代表服务使用情况的网络流量记录或服务器日志中收集的一组请求开始,
我们的想法是将这些数据划分到与特定时间段相对应的槽中.

然后, 这些槽组中的每一个都通过清理算法运行, 以从组中移除攻击, 
直到检测到的异常数量降至特定阈值以下. 
定义阈值取决于所讨论的环境和数据, 但此算法
也可以很容易地适应使用固定次数的迭代来执行清理(只需更改 until 条件).

在给出算法的伪代码之前, 我们定义了输入数据, 作出假定并列出了变量.

***数据*** 从服务的使用中获得的一组请求, 分成对应于特定时间段(例如 1 天)的消息槽,
d0, d1, ..., dn-1, 其中 d0 是第一个槽，dn-1 是最后一个.

***假定*** 在收集训练流量的整个期间没有攻击分布. 这意味着对A的一个给定某个攻击, 它不会出现在所有插槽 di 中.

***变量*** Gi 是手动验证并给出的良好(干净)的请求集; Bi 是人工验证给出的不良请求集, 即带有攻击; 
Ai 为上次迭代检测到的异常请求数

![](./papers/figures/3.1.png)

在算法开始之前, 我们如上所述初始化 Gi 和 Bi 以及 Ai. 然后算法的工作原理如下:

* 在第 1 行中, 变量 i 被初始化为 0.
* 在第 2 行中, 循环开始并运行, 直到检测到的异常数量(Ai的总和)下降到第10行中的某个阈值以下.
* 在第 3 行中, 异常检测系统在训练模式下使用来自 A(i mod n) \ B(i mod n)的请求集执行.
* 在第 4 行中, 异常检测系统在检测模式下针对来自 A(i + 1 mod n) \ G(i + 1 mod n) 的请求集执行。
* 在第 5 到 8 行中, 对于异常检测系统认为异常的每个请求r, 执行手动验证以确认它是否真的是攻击.
如果是攻击, 则将 r 添加到集合 B(i + 1 mod n) 中. 否则, 如果不是攻击, 则将 r 添加到集合 G( i + 1 mod n) 中.
* 在第 9 行，i 变量递增.
* 最后, 在第 11 行中, 返回经过过滤的没有异常流量(即没有攻击)的训练请求集 T 返回.

### 3.4 相似性度量

基于异常的 IDS 从一组训练数据中的观察中学习并构建出正常行为模型.
然后, 为了评估某个请求是否异常, 系统将请求与从训练数据中构建的模型进行相似度比较.

以往文献中提到的大多数现有的基于异常的系统都是基于统计模型, 
并且基于函数计算相似度, 通常是距离函数, 其输出会与预定义的阈值进行比较.

这种函数的选择取决于正在使用的模型和考虑的对象数量.
例如, HTTP 请求中参数内容的长度, 
可以使用 Kruegel 和 Vigna [30] 中看到的 Chebyshev 不等式来定义.
Wang 和 Stolfo [32] 中的马氏距离同时考虑了多个相关的均值和标准差值.

阈值的设置是影响系统精度的一个非常重要的方面.
设置低阈值意味着警报数量多, 因此漏报率低, 但误报率也高.
另一方面, 设置高阈值, 意味着以大量假阴性为代价的少量警报和少量误报.
因此, 确定阈值的正确值很困难, 并且取决于被监控的系统及其环境,
以及用于训练的数据质量.

### 3.5 检测模型

在本节中, 我们简要描述九种已提出的用于 Web 攻击的异常检测模型,
特别是 Kruegel 和 Vigna [30], Ingham [38] 以及 Wang 和 Stolfo [32],
它们包含在第3.6节中描述的IDS中, 随后在第 4 章中进行了评估.

#### 3.5.1 长度

Kruegel 和 Vigna [30] 指出属性的长度可以在许多情况下用于检测异常请求.
由于参数是通常是固定大小的标记或从用户输入获得的短字符串,
同一个 Web 应用程序中请求参数值的长度不应该相差太多.
但是, 当恶意输入传递给web应用程序里面的参数时, 长度值很可能与正常请求不同.

该模型旨在近似参数长度和检测显着偏离观察到的正常行为的实例.
在训练阶段, 属性长度字符串的均值和方差σ2被测量.
至于检测阶段, 使用切比雪夫不等式, 系统通过以下方式计算概率, 使该概率具有所观察长度l的属性.

在干净的数据(没有攻击)上训练, 这个措施很可能准确检测跨站点脚本(XSS)和缓冲区溢出攻击,
因为与这些攻击相关的请求通常是比正常请求长得多, 但会错过攻击长度与正常请求相似.
由于该模型不区分请求的各个部分, 如果攻击表现为训练数据, 这个措施不太可能有用.
此外, 还有一些类型的攻击(例如Apache分块传输错误或Nimda1的变体)足够短以致正常通过, 
或者如果它们太短, 可以使用填充增加它们的长度以正常通过. 
因此, 施加最小长度不会阻止每次攻击, 
并且此外, 由于这个模型接受的基本上是字符串, 这其中的一些在HTTP中甚至可能不合法, 
攻击者有一定灵活度制定他的攻击.

该模型通过对字符串用像通常一样关闭均值的长度进行分类来进行泛化.
考虑例如英语中包含n个单词的有效句子的数量, 
如果这个模型被应用于标记, 它会过度泛化.

因此, 这个模型本身不太可能很有帮助, 但考虑正常请求的长度有严格的上限, 它可以与其他模型结合使用.
在我们的测试中, 我们将 Length 模型评估为独立的和作为模型组合的一部分(第3.5.7节).

#### 3.5.2 字符分布

关于比较新请求中和训练数据中字符分布的差异, 已经有两种不同方法被提出.

Kruegel 和 Vigna [30] 使用ASCII的256个字符分布模型, 
通过将 ASCII 字符分组为 6 个可能的段：0、1-3、
4-6、7-11、12-15 和 16-255, 
然后使用 χ2 检验计算新请求的异常分数.

Wang 和 Stolfo [32] 使用了一个字符分布度量来检测网络数据包上的异常负载, 
他们通过在检测阶段使用马氏距离计算新数据与预先计算的配置文件的相似性.
字符分布泛化是通过接受任何具有能匹配学习到的分布的字符分布的字符串实现
的, 更准确地说, 它们允许相似而不是相同的字符分布.

当对过滤数据进行训练时, 这些方法是可能检测到跨站点脚本(XSS)和缓冲区溢出攻击的, 
因为它们通常具有独特的字符分布.

由于这些方法无法区分请求的各个部分,
在未经过滤的包含攻击的数据上训练时, 它们不太可能表现良好.
然而, HTTP协议的灵活性减小了这些方法的有效性, 
因为攻击者可以使用填充以产生接近正常的字符分布,
特别是在存在众多标准化的数据编码方式下.

除非在验证之前对 HTTP 请求执行网络规范化(或在基于异常的 IDS 的情况下进行检测), 
即将请求简化为最简单或标准的形式, 攻击可以使用上述提到的技术伪装成正常的字符分布模型.

##### 3.5.2.1 马氏距离

马氏距离是用于比较两个统计分布的一个标准距离度量，
这提供了一种有用的方法测量新的(未知的)有效负载样本和先前计算的模型之间的相似度。

Wang 和 Stolfo [32] 计算了新观察到的有效负载与对相应长度范围进行计算的模型之间字节分布距离。
距离分数越高，越有可能负载异常。
马氏距离d计算如下: d2(x,y)T =(x−y)C−1(x−y)
其中 x 是新观察的特征向量，y 是从训练示例计算的平均特征向量。 C−1是
协方差矩阵的逆矩阵，其中 Cij = Cov(yi,yj)。
然后，为进一步加快计算速度，他们得出了简化的
马氏距离，其中方差被标准差替代。
这里的 n 对应的是 ASCII 字符集256个字符：
d(x,y)=n−1 |x−y| <∞ i=0 σi
然而，标准差有可能为零，所以他们引入平滑因子α：
d(x, y) = n−1 |x−y| i=0 σi +α

至于平滑因子 α，因为 Wang 和 Stolfo 没有指定如何定义它，
在我们的测试中使用了 0.001 的
值（但它可以更改，因为它是运行时参数）。

为了计算马氏距离的增量版本，必须计算每个 ASCII 字符在每个被观测样本上的平均值和标准差。

为了实施马氏距离，Knuth [52] 描述的更新的技术被使用了。
由于标准差是方差的平方根，方差计算可以使用期望值E重写如下：
Var(X) = E[X − E(X2)] = E(X2) −[E(X)]2

Ingham [38] 描述了该度量的实际实现。
举个例子，计算请求的相对字符频率（字符 c 的f(c)）。使用
Knuth 的方法，从训练请求中看到的每个字符的均值和平方均值（两个 256 元素数组：xc 和 σc）被记录。

距离计算如下：
d = 255 f(c)−xc c=0 σc +α
下一步，由于 d 是一个有限映射，它被映射到区间 [0, 1]: s = 1 d ∈ [0, 1]1d>1 ln(d+e−1)
其中 e 是自然对数的底数。

d ≤ 1 值的映射是有道理的，因为距离越大，
数据项越异常。
实验表明，来自训练数据集的请求具有距离 d > 1，
所以很少有请求明显很接近所学习到的分布的很小距离。
在我们的测试中，此度量适用于整个 HTTP 要求。

##### 3.5.2.2 理想化特征分布的卡方检验

Kruegel 和 Vigna [30] 的方法是基于这样的观察，即属性具有规则的结构，大部分是人类可读的，并且几乎总是只包含可打印的字符。
因此，此方法试图通过查看查询参数的字符分布来模拟查询参数的正常行为。
通常，这些属性中的字符主要是字母和数字，以及一些特殊字符。就像在英文文本中一样，这些字符并不是均匀分布的，而是确实以不同的频率出现。
尽管不遵循与英文文本相同的分布，但查询参数的字符频率之间存在相似之处。

他们通过生成包含字符 c 的相对频率的字符频率 fc 的排序列表来测量字符相对频率，
并注意到相对频率对于非攻击请求下降缓慢，但对于缓冲区溢出攻击有陡峭的下降，而随机数据没有下降。

他们从训练数据中引出的字符分布被命名为理想化特征分布 (ICD)，其中 255 ICD(i) = 1.0。 ICD 被排序以让i=0。

最常见的频率是 ICD(0)，最不常见的是 ICD(255)。
作为训练数据中请求的字符分布的平均值，ICD 的计算是在训练期间完成的。

为了进行测试，他们将 ICD（预期分布）和测试请求的分布（观察到的分布）分组为six2 桶，如下所示：

然后，一旦分组，他们使用 Pearson χ2 检验的变体来确定 CGI 参数值的字符分布是否与训练数据的字符分布相似，如下所示：
χ2 = i<6 (Oi−Ei)2 i=0 Ei
这里 Ei 是 ICD 的 bin i，Oi 是观察到的分布的 bin i。然后，将 χ2 与表中的值进行比较，并返回相应的概率。
派生值 p 用作此模型的返回值。当从理想化字符分布中抽取样本的概率增加时，p 也会增加。
该模型作为组合的一部分（第 3.5.7 节）和独立模型进行了测试。

#### 3.5.3 参数排序

Kruegel 和 Vigna [30] 提出的另一种方法是基于请求中的 CGI 参数顺序。
对服务器端程序的合法请求，通常通过客户端脚本或 HTML 表单生成而不是让用户自己手动键入 URI 的输入参数。

所以，由于程序逻辑通常是顺序的，因此这些合法请求通常包含相同固定顺序的参数，

即使对于特定请求，其中一些参数被省略，仍然保留了参数的相对顺序。
但是，如果请求是手工制作，它们的顺序可以完全任意，
这可能暗示一个貌似可信的攻击。

此方法确定参数的特定顺序是否是与训练期间观察到的一致。
在训练阶段，构建出一个有向图表示属性的顺序值。
至于检测阶段，试图遍历图，如果成功，则此方法返回异常分数为 1，否则返回 0。

该模型能够通过允许以最初在训练数据中看到的排序进行。
如果训练数据由 abcd 和 dbac 组成，得到的有向图将如图 3.1 所示（来源 [38]）。

图 3.1：由 abcd 和 dbac 导出的示例有向图。

这种方法有可能区分请求的区域，
但仅作为组合模型的一部分进行了测试（第3.5.7)，
因为不清楚如何将整个 HTTP 请求映射到与 n-gram 方法不同的顺序关系。

#### 3.5.4 存在或不存在参数

正如上面对 Ordering 模型的解释，URI 参数是通常由脚本或 HTML 表单提供，而不是由人手工填写。
因此，正如 Kruegel 和 Vigna [30] 所指出的，在合法请求中参数存在数量、名称和顺序上的规律性。
在训练阶段，这种方法通过学习给定程序路径的参数将正常行为模型化。
在检测阶段，如果参数与训练阶段观察到的相同则返回值为1，否则为 0。

这种方法的泛化是有限的，
因为观察对特定资源使用特定个性化请求参数的多样化请求，意味着这些参数的任意组合将也算正常。

除非用于识别组合的参数排序模型之前从未见过，这个单独的方法不是特别有用。
由于上一段解释的原因，这个方法仅作为组合模型的一部分进行测试（第 3.5.7 节）。

#### 3.5.5 Token查找器

该模型背后的想法是确定特定查询属性的值是否从有限的可能集合（枚举）中选择，或者实际上是随机的。

由于 Web 应用程序通常对某些属性需要某些特定的值（如标志或索引），
当对手试图使用这些属性来传递非法值，攻击可以被检测到。

在训练阶段，计算使用a 的出现次数递增数字 1, . . . , i的两个函数 f 和 g 之间的统计相关性 p 
来判断参数 a 是否为枚举：
请注意，f 是严格增加的，而 g 仅在新值出现在训练数据中的情况下增加。

相关参数 ρ 是根据 f 和 g 及其各自的方差计算的，并且协方差如下图：

如果 ρ < 0，则 f 和 g 负相关，并且假定枚举。
否则，如果 ρ > 0，则 a 的值被推测是随机的。

由于 Kruegel 和 Vigna 没有指定在 ρ = 0 的情况下，我们假设 ρ ≥ 0 时是随机的。
当枚举在训练期间被假设，值被存储以供在检测阶段使用。

在检测阶段，如果训练数据表明值是随机的，则相似度为 1。
如果训练数据表明值是枚举的，值包含在学习集，相似度也是 1。
另一方面，如果该值不在学习集中，返回的相似度为 0。

至于泛化，如果考虑一个参数值枚举而不执行泛化，
而如果值为随机的，一切都被接受。
这意味着这个模型的泛化取决于服务器端程序。

此方法仅用作组合模型的一部分，因为不清楚如何将其应用于完整的 HTTP 请求。

#### 3.5.6 马尔可夫模型

通常，大多数 Web 漏洞在查询中会因具有异常长值的属性或包含多次重复不可打印的字符而被立即察觉。

使用上述解释过的基于顺序（第 3.5.3 节）和字符分布（第 3.5.2.1、3.5.2.2 节）的模型
可以轻松检测到这类攻击。
但在某些情况下，对手能够以更隐蔽的方式制造攻击，
使它们看起来更规则（例如，将不可打印的字符替换为组可打印字符）。
对于这种情况，查询属性的更详细的能够包含攻击的证据模型是必要的。

马尔可夫模型可以通过分析参数的结构，即描述所有正常合法值的常规语法。
基本方法是泛化语法，只要它看起来是合理的并在丢失太多信息之前停止。
使用马尔可夫模型来实现这个合理泛化的想法。

马尔可夫模型是一种非确定性有限自动机 (NFA)，它具有与转换相关的概率。
这个模型的基本思想是建立这样一个与训练数据完全匹配自动机，
通过一系列的状态合并操作进行压缩，从而实现泛化。
马尔可夫模型的输出包括从它的开始状态到终止状态的所有路径，
以及一个给定单词/字符串 w（输出符号序列）的概率，
通过自动机产生 w 所有不同路径的概率的总和计算。

至于单一路径的概率，
它被计算为每个采取的转换的概率的乘积，
它在检测阶段被用作相似度度量。

马尔可夫模型通过有向图表示 HTTP 请求的结构。 
Kruegel 和 Vigna [30] 使用马尔可夫模型作为其系统的一部分，仅在 CGI 程序参数中检测到攻击，

但由于 HTTP 请求的高度多样性，任何给定请求的概率都很小，
他们只是用它来查看模型是否能够生成有问题的请求。
由于我们应用了这种使用完整的 HTTP 请求的方法，问题会更糟，

因为有更多的正常多样性的地方导致任何给定 HTTP 请求较低的概率。

如上所述，在马尔可夫模型中，通过一系列状态合并操作实现了模型的泛化，从而可以允许训练数据中未出现的组合。然而，由于新颖值会导致概率为0，因此在非常动态的环境下，该模型可能表现不佳，除非保持更新。
对于训练阶段，该方法基于标记学习了正常行为，以便能够区分请求的不同区域，并使其能够在后续检测到HTTP请求的不同区域中检测到攻击。
马尔可夫模型既可以作为独立模型进行测试，也可以作为模型组合的一部分进行测试（第3.5.7节）。

#### 3.5.7 组合

Kruegel和Vigna [30] 提出了一个系统来检测HTTP CGI请求中的Web攻击。因此，他们只考虑了HTTP请求的初始行，忽略了所有其他内容，例如头部。他们的系统由以下模型的组合组成（因此我们称之为组合模型）：

* CGI参数值的长度。
* CGI参数值的字符分布。
* 用于学习参数值字符串结构的马尔科夫模型。
* CGI参数值的枚举或随机参数值。
* 参数的存在或不存在。
* 参数的顺序。

为了动态确定每个模型的正常阈值，对训练数据进行了两次扫描，并计算出阈值为最高值的10％以上。
在检测阶段，每个指标的权重相等，系统返回一个二进制指示，表示请求是否被视为正常。每个请求的组合结果是六个指标的平均值。如果组合是AND操作，那么单个模型可能会导致请求被拒绝，而如果组合是OR操作，则任何模型的接受都会导致组合的接受。
组合方法的概括是各个单独模型的概括，因为它们的概括方式不同，使用平均值允许组合考虑特定模型过度或欠度概括引入的问题。
为了按照[30]中最初提出的方式评估六种模型的组合，使用HTTP请求的初始行进行测试，例如在图2.5中看到，并忽略剩余的标题数据行。

#### 3.5.8 N-Grams

n-gram（n元组）[54]是子序列，也就是在文本中滑动长度为n的窗口得到的字符串。例如，给定文本abcdef和n=4，那么结果就是4元组：abcd，bcde，cdef。为了构建保存的n-gram集，需要将每个字符串拆分成n元组，并将每个新元组存储到集合中。

由于来自训练数据集的字符串长度可能会变化，如果在将字符串转换为n-gram的过程中字符串长度小于n，则整个字符串将被视为n-gram，然后被保存或测试。参数n控制模型的粒度，当它减小到1时，模型失去了语法结构信息，并被简化为一个文法字母表，该字母表接受由其字符组成的任何输入字符串。否则，如果n大于所有输入字符串的长度，则模型仅保存已训练的字符串，不接受任何更多内容，从而过度简化。

此模型的检测阶段简单地检查问题n-gram是否在训练中观察到，也就是它们是否存在于从训练数据中学到的n-gram集中。它返回一个相似度值s，计算公式如下：

s = 在请求中也在训练数据中出现的n-gram数量 / HTTP请求中的n-gram数量 ∈[0,1]

N-grams可以编码整个HTTP请求的结构，并因此可以区分HTTP请求中的各个区域。使用标记，可以通过将代表输入的标记序列编码为有向图来建模请求的结构。n-gram导致有向图，通用化类似于参数顺序模型（第3.5.3节）中描述的那样。

在我们的实验中，应用于完整的HTTP请求，并使用标记测试了五个变体，n分别为3、4、5、6、7。

### 3.6 基于异常的 IDS

我们的工作是设计一个由一系列基于异常检测模型组成的IDS，以便评估和评估这些模型的准确性，这可以被视为一个完全成熟的基于异常检测的IDS解决方案的概念验证。

系统实现了九个基于异常检测的模型，分别是长度（第3.5.1节）、马氏距离（第3.5.2.1节）、理想化字符分布的χ2（第3.5.2.2节）、参数排序（第3.5.3节）、参数的存在或不存在（第3.5.4节）、标记查找器（第3.5.5节）、马尔可夫模型（第3.5.6节）、组合（第3.5.7节）和N-gram（第3.5.8节）。所有模型都使用由Kenneth Ingham开发的IDS::Test在Perl中实现，并可在相同的条件、数据集和环境下独立运行每个模型（以及Kruegel和Vigna [30]的6个模型的组合）。

为了表示HTTP请求数据，IDS可以根据模型使用字符字符串或标记流，其中包含相关值。通过使用标记，系统能够学习请求的结构和含义。

对于每个异常检测模型，系统分别进行训练和检测两个不同的阶段。在训练阶段，它确定请求的特征并创建描述正常行为的统计模型。检测阶段是新请求实例针对模型进行测试以确定它们是攻击的可能性的阶段。在检测阶段，系统测试请求并返回相似度值s∈[0,1]，它表示被测试的请求与训练模型的预期之间的相似度。s = 0的值表示新请求，即从训练数据中没有观察到或派生的完全新请求。当s = 1时，它表示与训练期间观察到的请求没有差异的请求。任何s值介于两者之间都表示中间相似度。根据第4章中提供的所有结果，按照[38]建议的方式允许更好的比较，所需的准确性是相对慷慨的真正正例分数为0.852，这意味着所有低于此值的结果都被认为是异常的（等于或高于此值的结果被认为是正常的）。

对于任何原始返回不在该区间内的模型，即 s ∈/ [0, 1]，它们的相似性结果都将被映射到这个范围内。

### 3.7 泛化启发式方法

为了增加请求中特定区域的泛化能力，检测系统采用了几种启发式方法。为了使用这些启发式方法，IDS检查请求中具有高度变异性的特定区域值是否形式正确，然后用是否符合标准的指示替换它们。
经过对我们的数据集的分析，我们评估了HTTP请求的哪些区域适合应用泛化，并决定使用以下启发式方法：
IP地址和主机名：系统将验证IP地址或主机名的形式是否符合Internet标准，而不是学习Internet中的每个IP地址和主机名。
哈希：哈希在HTTP请求中存在，例如在实体标记或Cookies中的会话ID中（例如Content-MD5或PHPSESSID）。由于哈希的目的是唯一的，因此对于基于异常的IDS来说，学习每个哈希是没有意义的。因此，系统只验证哈希的形式（字符集和长度），并返回哈希是否有效。
日期：对于试图学习HTTP请求结构的IDS来说，日期是一个问题，因为它们每天都会更改。因此，系统不是学习每一天，而是验证所涉及日期是否符合RFC 2616标准[22]。

文件类型：大多数 Web 服务器的请求都是针对少数文件类型（例如 HTML 文件、JPEG 文件、PHP 脚本等）。系统不会学习网站上的每个文件，因为我们的测试数据显示其中许多文件是服务器动态创建的照片或页面。系统会尝试根据文件名的最后一部分来识别资源路径的文件类型，并返回与扩展名相对应的标识，而不是整个文件名。

文件名长度：该启发式方法是对前面提到的文件类型的补充。当文件类型未知时，系统会返回文件名的长度。

仅小写字母：在 HTTP RFC 2616 标准 [22] 中，指出每个报头字段由名称后跟冒号（“:”）和字段值组成，字段名称不区分大小写。由于这个事实，不同的客户端使用不同的方案来处理相同的报头，因此系统需要将所有报头字段名称视为不区分大小写的标准化处理。此启发式方法将报头（名称和值）映射为小写字母，从而增加泛化性，减少系统学习的实例数量。

Email用户长度 ”From:” HTTP头字段可以包含请求方的电子邮件地址，格式为
username@hostname。地址的hostname部分可以像IP地址和主机名启发式那样进行验证，但对于username来说，除了发送电子邮件之外，没有简单的方法来验证它。为了防止username缓冲区溢出攻击，可以测量其长度，以便系统学习它，这就是这个启发式的作用。
尝试替代方法 我们观察到几个HTTP头行会导致系统生成许多误报。由于这些行对于Web服务器识别所请求的资源并不重要，系统尝试删除以下头行：引用者、Cookie、接受语言、接受字符集和接受，一次删除一个，如果删除一行后，请求通过相似性测试，则接受并处理该请求而不带有异常的头行。如果IDS作为反向代理实现，则删除这些行可以保护Web服务器免受HTTP请求这些部分中存在的攻击，但删除Cookie（它们可以编码状态，例如PHPSESSID）最终可能会阻止用户正确使用浏览网站。除了Cookie之外，最糟糕的情况就是客户端将接收默认版本的Web页面，而不是定制为其首选语言、字符集或文件格式的Web页面。
